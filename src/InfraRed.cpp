//==============================================================================
// Структура NEC пакета: 32 бита, 4 блока по 8 бит, LSB<-MSB
// [START] [адрес-8бит] [~адрес-8бит] [команда-8бит] [~команда-8бит][END-опционально]
// Но не все пульты соблюдают это правило, хотя по параметрам вроде NEC.
//------------------------------------------------------------------------------
#include "InfraRed.h"

// Конструктор. Получает указатель на функцию времени, отсчитывающую !!! микросекунды
InfraRed::InfraRed(PinName pin, uint32_t (*getMicros)()) : m_getMicros(getMicros) {
  _pin = pin;
  pinMode(_pin, GPIO_Mode_IPU);
  pinExtiInit(_pin, EXTI_Trigger_Falling);
}

void InfraRed::receive(void) {
  if (EXTI_GetITStatus(extiLine(_pin)) == RESET) { // На "нашем" пине сигнал не изменился
    return;                                        // Не наше прерывание, уходим.
  }
  EXTI_ClearITPendingBit(extiLine(_pin)); // Сброс прерывания

  uint32_t now = m_getMicros();
  uint16_t time = now - _lastTime; // Интервал с предыдущего прерывания
  _lastTime = now;

  if (time > _NEC_MAX_PACKET_LENGTH) { // Сигнала не было дольше. чем максимальная длительность пакета
    _repeatCount = -1;                 // Значит автоповтора быть не могло.
  }

  if (time > _NEC_START_MIN && time < _NEC_START_MAX) { // Длительность стартового импульса.
    _start = true;                                      // Начинаем прием нового пакета
    _buffer = 0;                                        // Почистим буфер
    _counter = 0;                                       // Сбросим счетчик принятых бит
    return;
  }
  // Если мы сюда добрались, значит получен один из содержательных импульсов пакета
  uint8_t bit = (time >= _NEC_HIGH_MIN && time <= _NEC_HIGH_MAX) ? 1 : 0; // Проверка на HIGH или LOW импульс
  _buffer = _buffer << 1 | bit;                                           // Поместим принятый бит в буфер
  if (++_counter == _NEC_PACKET_SIZE) {                                   // Если приняли все биты пакета
    _start = false;                                                       // завершаем чтение
    _packet = _buffer;                                                    // Копируем буфер в пакет
    _buffer = 0;                                                          // И почистим буфер
    _ready = true;                                                        // Признак наличия принятого пакета
    _repeatCount = 0;                                                     // Сбросим счетчик повторов
    return;
  }
  // Обработаем автоповторы. 
  // Мы здесь, потому что буфер еще не заполнен. Смотрим, что за импульс.
  // Если это сигнал автоповтора, то проглотим некотрое количество таких импульсов
  // чтобы избежать "дребезга", а потом взведем флаг готовности данных.
  // И прикладной код просто прочитает предыдущий принятый пакет.
  if (time > _NEC_REPEAT_MIN && time < _NEC_REPEAT_MAX) {
    if (_repeatCount != -1) {
      _repeatCount++;
    }
    if (_repeatCount > _NEC_SKIP_REPEAT) {
      _ready = true;
    }
  }
}

//==============================================================================
// Признак наличия принятого пакета. Возвращает true, если принят пакет.
// Признак сбрасывается после вызова данной функции.
//------------------------------------------------------------------------------
bool InfraRed::ready() {
  if (_ready) {
    _ready = false;
    return true;
  }
  return false;
}

uint32_t InfraRed::readPacket() {
  return _packet;
}

uint8_t InfraRed::readAddress() {
  return ((uint32_t)_packet >> 24);
}

uint8_t InfraRed::readCommand() {
  return ((uint32_t)_packet >> 8 & 0xFF);
}

uint16_t InfraRed::getKeyCode() {
  return (readAddress() << 8) | readCommand();
}

//==============================================================================
// Проверка четности единиц в пакете.
// Возвращает true, если число единиц в пакете нечетное, и false, если четное.
//------------------------------------------------------------------------------
// bool InfraRed::chkParity(uint32_t x) {
bool InfraRed::chkParity() {
  uint32_t x = _packet;
  x ^= x >> 16;
  x ^= x >> 8;
  x ^= x >> 4;
  x ^= x >> 2;
  x ^= x >> 1;
  return x & 1;
}

//==============================================================================
// Проверка адреса. Возвращает true, если адрес прямой соответствует адресу
// инверсному.
//------------------------------------------------------------------------------
// bool InfraRed::chkAddress(uint32_t x) {
bool InfraRed::chkAddress() {
  uint8_t b0 = (_packet >> 24) & 0xFF; // старший байт (адрес)
  uint8_t b1 = (_packet >> 16) & 0xFF; // ~адрес
  return (b0 ^ b1) == 0xFF;
}

//==============================================================================
// Проверка команды. Возвращает true, если команда прямая соответствует команде
// инверсной.
//------------------------------------------------------------------------------
// bool InfraRed::chkCommand(uint32_t x) {
bool InfraRed::chkCommand() {
  uint8_t b2 = (_packet >> 8) & 0xFF; // старший байт (команда)
  uint8_t b3 = (_packet) & 0xFF;      // ~команда
  return (b2 ^ b3) == 0xFF;
}
